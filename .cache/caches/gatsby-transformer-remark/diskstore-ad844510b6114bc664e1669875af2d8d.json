{"expireTime":9007200823659037000,"key":"transformer-remark-markdown-html-4bf8c72a4262ea4000769396879117d2--","val":"<p>In an earlier post I talked about the <a href=\"http://savyounts.com/decorating_tacos\">Decorator Design Pattern</a>. The Decorator pattern is like changing the \"skin\" of a class, you're only adjusting the outside look of it, not anything that actually happens within the class itself. Today, we're going to dive in and talk about how to change the \"guts\" of a class with the Strategy Pattern.</p>\n<p><img src=\"https://media.makeameme.org/created/prepare-the-strategy.jpg\"></p>\n<blockquote>\n<p>The intent of the Strategy pattern is to define a family of algorithms, encapsulate each one and make them interchangeable. These algorithms can also vary independently from the clients that use them.</p>\n</blockquote>\n<p>Oooo scary, algorithms. No worries, my friend, we aren't necessarily talking about big computer-sciency algorithms. Instead we're talking more about any code that follows a sequence of steps to get a result.</p>\n<p>To help illustrate how a the strategy pattern works, we're going to use another food favorite, sushi.</p>\n<p>If I have a Sushi class that makes a variety of types of rolls I could have something that looks like this:</p>\n<pre><code>class Sushi\n  attr_reader :base, :type\n\n  def initialize(type)\n    @base = \"rice\"\n    @type = type\n  end\n\n  def price\n    if type == \"California Roll\"\n      5\n    elsif type == \"Philadelphia Roll\"\n      4\n    elsif type == \"Rainbow Roll\"\n      7\n    else\n      \"we dont serve this kind of sushi roll, I can give you a bowl of rice for $3\"\n    end\n  end\n\n  def make_soosh\n    if type == \"California Roll\"\n      \"rolling up my crab, avocado and cucumber in my #{base}\"\n    elsif type == \"Philadelphia Roll\"\n      \"rolling up my Avocado, shrimp tempura, cucumber, tobiko in my #{base}\"\n    elsif type == \"Rainbow Roll\"\n      \"rolling up my crab, avocado, cucumber, tuna, avocado, salmon, shrimp, yellowtail in my #{base}\"\n    else\n      \"we dont serve this kind of sushi roll, so all you have is a bowl of rice.\"\n    end\n  end\n\nend\n\nrainbow_roll = Sushi.new(\"Rainbow Roll\")\nputs rainbow_roll.ingredients   #=> rolling up my crab, avocado, cucumber, tuna, avocado, salmon, shrimp, yellowtail in my  rice\nputs rainbow_roll.price         #=> 7\n</code></pre>\n<p>As you can see this class has a lot going on, but it also only has three different types of sushi you can choose between (or a bowl of just rice). Let's be real, we haven't even gotten to the good rolls, and I guess this place doesn't even have any sort of customized rolls... super lame.</p>\n<p>Let's analyze this Sushi class real quick, what do we notice? First off, the base for all the rolls is the same and we can assume that the base price is the same since it's just rice. The only thing that differs it its behavior -- what ingredients are listed out for each type and the price associated with them. There are also a lot of conditionals...</p>\n<p>These are all indicators that you may want to use a Strategy pattern. Now we'll abstract that logic so we can customize our own rolls and behavior.</p>\n<p>First we will make an updated Sushi class that can be initialized with some ingredients and has simple #price, #all<em>ingredients and #make</em>soosh methods:</p>\n<pre><code>class Sushi\n  attr_accessor :ingredients\n  attr_reader :base\n\n  def initialize(*ingredients)\n    @base = \"rice\"\n    @ingredients = *ingredients\n  end\n\n  def price\n    3.0 + ingredients.reduce(0){ |sum, i| sum + i.price}\n  end\n\n  def all_ingredients\n    ingredients.collect{|i| i.name}.join(\", \")\n  end\n\n  def make_soosh\n    \"rolling up my #{all_ingredients} in my #{base}\"\n  end\n\nend\n</code></pre>\n<p>Poof. No more conditionals. Next we need to make ingredient classes...</p>\n<pre><code>class Avocado\n  def price\n    1.0\n  end\n\n  def name\n    \"avocado\"\n  end\nend\n\nclass Crab\n  def price\n    1.0\n  end\n\n  def name\n    \"crab\"\n  end\nend\n\nclass Cucumber\n  def price\n    0.5\n  end\n\n  def name\n    \"cucumber\"\n  end\nend\n</code></pre>\n<p>Now for some custom sushi magic</p>\n<pre><code>cali_roll = Sushi.new\ncali_roll.ingredients &#x3C;&#x3C; Cucumber.new\ncali_roll.ingredients &#x3C;&#x3C; Crab.new\ncali_roll.ingredients &#x3C;&#x3C; Avocado.new\n\nputs cali_roll.price     #=>  5.5\nputs cali_roll.make_soosh   #=> rolling up my avocado, cucumber, crab in my rice\n</code></pre>\n<p>So what did we just do?! First off, our Sushi class is just a base, it holds all the information that EVERY sushi needs to know, which in this case it's just the base price and ingredients, as well as how to manipulate them. Then we will put all of the custom functionality in different classes. To connect the two we simply use dependency injection.</p>\n<blockquote>\n<p>Dependency injection is a technique whereby one object (or static method) supplies the dependencies of another object. A dependency is an object that can be used (a service). An injection is the passing of a dependency to a dependent object (a client) that would use it.</p>\n</blockquote>\n<p>AKA instead of creating dependencies throughout your code by either hardcoding ingredients or even creating new instances of another class within your base class, you can separate and inject them by adding an instance of the strategy  in the initialize method of your base class.</p>\n<p>This gives us the freedom to make ANY ingredient class we want, <strong>as long as it responds to a #price and #name method.</strong> If we want a Salmon class, go for it. If you want an Eel class, more power to ya. If you want a Poprocks class (yes, I have had Poprocks on my sushi), by all means, make a Poprocks class, just make sure it responds to the correct methods.</p>\n<p>*\"But why #price and #name?\" *</p>\n<p>In this example, our ingredient classes need to respond to #price and #name because those are the methods that our Sushi class is calling on those instances. If Sushi did something like:</p>\n<pre><code>* #Sushi class*\n\n  def shout_ingredients\n    ingredients.collect{|i| i.shout}.join(\", \")\n  end\n</code></pre>\n<p>Then all of our ingredient methods would need to respond to a #shout method as well:</p>\n<pre><code>*#Avocado class*\n\ndef shout\n    \"AVOCADO\"\n  end\n</code></pre>\n<p>This way you can insert any food into sushi, but won't be able to insert an object that doesn't respond to these methods.. something like, a Panda.  </p>\n<pre><code>class Panda\n  def type\n    \"I'm a Panda\"\n  end\n\n  def nomnom\n    \"I eat bamboo\"\n  end\n\nend\n\npanda_sushi = Sushi.new\npanda_sushi.ingredients &#x3C;&#x3C; Panda.new\n\nputs panda_sushi.price    #=> NoMethodError: undefined method `price' for #&#x3C;Panda:0x007fbe4b3dc3c0>\n</code></pre>\n<p><img src=\"https://i.imgflip.com/1bukvo.jpg\" alt=\"We don&#x27;t want panda sushi...\"></p>\n<p>Let's <em>wrap</em> it all up.</p>\n<p>We use the Strategy pattern to change the \"guts\" of an object. Some of its main use cases are when you have a bunch of classes that only differ in behavior, or are littered in conditionals.</p>\n<p>A few benefits of the Strategy pattern are</p>\n<ul>\n<li>Families of related algorithms - strategies define a family of algorithms for contexts to reuse</li>\n<li>Alternative to subclassing - using Inheritance with subclasses hard-wires behavior into a context making it harder to maintain and extend</li>\n<li>you can vary the algorithm dynamically - this can happen independently of its context</li>\n<li>They eliminate conditional statements</li>\n<li>Provide a choice of implementations - they can provide different implementations for the same behavior</li>\n<li>Allows the context to choose its behavior at runtime</li>\n</ul>\n<p>A few drawbacks:</p>\n<ul>\n<li>Clients must be aware of the different strategies in order to take advantage of them</li>\n<li>Increased number of objects</li>\n</ul>\n<p>Differences between Strategy and Decorator patterns</p>\n<p>Decorator changes the \"skin\" of an object while Strategies change the guts. When working with Decorators you will be calling methods on the outermost object (which is one of your decorators), so you only have access to methods that your decorators have. That's why when using a Decorator you want your base class to be as lightweight as possible and you can let your decorators add functionality. On the other hand when working with Strategies, you will be calling methods on your base class (in this example, we call them on our Sushi object). Here the base class can be built out a bit more and you want each strategy to be as lightweight as possible since every strategy needs to respond to the same methods.</p>"}